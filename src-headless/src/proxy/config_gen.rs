//! Proxy Configuration Generator
//! 
//! **Config Generator** (Bộ sinh cấu hình - tạo proxy-config.yaml cho CLIProxyAPI)
//! 
//! This module generates the YAML configuration file that CLIProxyAPI expects.
//! Based on the logic from lib.rs start_proxy() function (lines 816-1084).

use crate::config::AppConfig;
use anyhow::{Result, Context};
use std::path::PathBuf;
use tracing::debug;

/// Generate proxy-config.yaml for CLIProxyAPI
/// **generate_proxy_config** (Tạo proxy config - sinh file YAML cho CLIProxyAPI)
pub fn generate_proxy_config(config: &AppConfig) -> Result<PathBuf> {
    let config_dir = get_proxy_config_dir()?;
    let config_path = config_dir.join("proxy-config.yaml");
    
    debug!("Generating proxy config at: {}", config_path.display());
    
    // Build proxy URL line if configured
    // **Proxy URL** (URL Proxy - proxy cho outbound requests)
    let proxy_url_line = if !config.proxy_url.is_empty() {
        format!("proxy-url: \"{}\"\n", config.proxy_url)
    } else {
        String::new()
    };
    
    // Build Amp API key line if configured
    // **Amp API Key** (Key Amp - cho Amp CLI integration)
    let amp_api_key_line = if !config.amp_api_key.is_empty() {
        format!("  api-key: \"{}\"\n", config.amp_api_key)
    } else {
        String::new()
    };
    
    // Build Amp model mappings section
    // **Model Mappings** (Ánh xạ Model - mapping cho Amp CLI)
    let amp_model_mappings_section = if !config.amp_model_mappings.is_empty() {
        let mappings: Vec<String> = config.amp_model_mappings.iter()
            .map(|m| format!("    {}: {}", m.from, m.to))
            .collect();
        format!("  model-mappings:\n{}\n", mappings.join("\n"))
    } else {
        String::new()
    };
    
    // Build OpenAI-compatible providers section
    // **OpenAI Compat** (Tương thích OpenAI - custom providers)
    let openai_compat_section = build_openai_compat_section(config);
    
    // Build API keys sections
    // **API Keys** (Các API Key - keys cho các providers)
    let gemini_section = build_gemini_section(config);
    let claude_section = build_claude_section(config);
    let codex_section = build_codex_section(config);
    
    // Build final config
    // **Final Config** (Config cuối - ghép tất cả sections)
    let proxy_config = format!(
        r#"# ProxyPal generated config
# Generated by proxypal-headless

port: {}
auth-dir: "~/.cli-proxy-api"
api-keys:
  - "proxypal-local"
debug: {}
usage-statistics-enabled: {}
logging-to-file: {}
request-retry: {}
{}
# Quota exceeded behavior
quota-exceeded:
  switch-project: {}
  switch-preview-model: {}

# Enable Management API
remote-management:
  allow-remote: false
  secret-key: "proxypal-mgmt-key"
  disable-control-panel: true

{}{}{}{}
# Amp CLI Integration
ampcode:
  upstream-url: "https://ampcode.com"
{}{}
  restrict-management-to-localhost: true
"#,
        config.port,
        config.debug,
        config.usage_stats_enabled,
        config.logging_to_file,
        config.request_retry,
        proxy_url_line,
        config.quota_switch_project,
        config.quota_switch_preview_model,
        openai_compat_section,
        claude_section,
        gemini_section,
        codex_section,
        amp_api_key_line,
        amp_model_mappings_section,
    );
    
    std::fs::write(&config_path, proxy_config)
        .context("Failed to write proxy config")?;
    
    Ok(config_path)
}

/// Get proxy config directory
/// **get_proxy_config_dir** (Lấy thư mục config proxy)
fn get_proxy_config_dir() -> Result<PathBuf> {
    let config_dir = dirs::config_dir()
        .ok_or_else(|| anyhow::anyhow!("Could not determine config directory"))?
        .join("proxypal");
    
    std::fs::create_dir_all(&config_dir)
        .context("Failed to create config directory")?;
    
    Ok(config_dir)
}

/// Build OpenAI-compatible providers section
/// **build_openai_compat_section** (Xây dựng section OpenAI compat)
fn build_openai_compat_section(config: &AppConfig) -> String {
    if config.amp_openai_providers.is_empty() {
        return String::new();
    }
    
    let mut section = String::from("# OpenAI-compatible providers\nopenai-compatibility:\n");
    
    for provider in &config.amp_openai_providers {
        section.push_str(&format!(
            "  - name: \"{}\"\n    base-url: \"{}\"\n    api-key-entries:\n      - api-key: \"{}\"\n",
            provider.name, provider.base_url, provider.api_key
        ));
        
        if !provider.models.is_empty() {
            section.push_str("    models:\n");
            for model in &provider.models {
                section.push_str(&format!("      - name: \"{}\"\n", model.name));
                if !model.alias.is_empty() {
                    section.push_str(&format!("        alias: \"{}\"\n", model.alias));
                }
            }
        }
    }
    
    section.push('\n');
    section
}

/// Build Gemini API keys section
/// **build_gemini_section** (Xây dựng section Gemini)
fn build_gemini_section(config: &AppConfig) -> String {
    if config.gemini_api_keys.is_empty() {
        return String::new();
    }
    
    let mut section = String::from("# Gemini API keys\ngemini-api-key:\n");
    
    for key in &config.gemini_api_keys {
        section.push_str(&format!("  - api-key: \"{}\"\n", key.api_key));
        if let Some(base_url) = &key.base_url {
            section.push_str(&format!("    base-url: \"{}\"\n", base_url));
        }
        if let Some(proxy_url) = &key.proxy_url {
            section.push_str(&format!("    proxy-url: \"{}\"\n", proxy_url));
        }
    }
    
    section.push('\n');
    section
}

/// Build Claude API keys section
/// **build_claude_section** (Xây dựng section Claude)
fn build_claude_section(config: &AppConfig) -> String {
    if config.claude_api_keys.is_empty() {
        return String::new();
    }
    
    let mut section = String::from("# Claude API keys\nclaude-api-key:\n");
    
    for key in &config.claude_api_keys {
        section.push_str(&format!("  - api-key: \"{}\"\n", key.api_key));
        if let Some(base_url) = &key.base_url {
            section.push_str(&format!("    base-url: \"{}\"\n", base_url));
        }
        if let Some(proxy_url) = &key.proxy_url {
            section.push_str(&format!("    proxy-url: \"{}\"\n", proxy_url));
        }
    }
    
    section.push('\n');
    section
}

/// Build Codex API keys section
/// **build_codex_section** (Xây dựng section Codex)
fn build_codex_section(config: &AppConfig) -> String {
    if config.codex_api_keys.is_empty() {
        return String::new();
    }
    
    let mut section = String::from("# Codex API keys\ncodex-api-key:\n");
    
    for key in &config.codex_api_keys {
        section.push_str(&format!("  - api-key: \"{}\"\n", key.api_key));
        if let Some(base_url) = &key.base_url {
            section.push_str(&format!("    base-url: \"{}\"\n", base_url));
        }
        if let Some(proxy_url) = &key.proxy_url {
            section.push_str(&format!("    proxy-url: \"{}\"\n", proxy_url));
        }
    }
    
    section.push('\n');
    section
}
